# -*- coding: utf-8 -*-

# 当遇到两个维度权衡的时候, 先确定一个维度, 然后按照另一个维度重新排列
# 若按照k来从小到大排序, 排完之后回发现k的排列并不符合条件, 身高也不符合条件, 两个维度都没确定下来
# 若按照身高h来排序, 身高一定是从大到小排(身高相同k小的站前面), 让高个子在前面 
# 此时我们确定一个维度就是身高, 前面的节点一定比本节点高

# 模拟插入过程
# 以[[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]举例
# 身高排序之后为[[7,0],[7,1],[6,1],[5,0],[5,2],[4,4]]
# 插入[7,0]: [[7,0]]
# 插入[7,1]: [[7,0],[7,1]]
# 插入[5,0]: [[5,0],[7,0],[6,1],[7,1]]
# 插入[5,2]: [[5,0],[7,0],[5,2],[6,1],[7,1]]
# 插入[4,4]: [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]

def aa(people):
    # 按照h维度的身高从高到低排序, 确定第一个维度
    # lambda返回的是一个元祖: 当-x[0](维度h)相同时, 再根据x[1](维度k) 从小到大排序
    people.sort(key=lambda x: (-x[0], x[1]))
    que = []
    # 根据每个元素的第二个维度k, 贪心算法, 进行插入, people已排序过了, 同一高度时k值小的排前面
    for p in people: que.insert(p[1], p)
    return que


if __name__ == "__main__":
    print aa([[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]])
    print aa([[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]])
