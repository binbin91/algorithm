# -*- coding: utf-8 -*-

# 解体思路:
# 因为是排列组合，通过交换位置来找到字典序更大的排列
# 假设原数组交换位置的元素下标为l, r，即nums[l] < nums[r]才可以在交换后得到更大的排列
# 1. 找到下标l位置, 从后往前遍历, 找到不满足升序的第一个元素 
#    例如: [1,3,5,4,3,2], 从后往前遍历, 1<3满足条件, 下标l为1, 即nums[l] = 3
# 2. 从大于下标l位置的元素且尽可能最小的数进行替换
#    例如: [1,3,5,4,3,2], 从后往前遍历, 大于3(nums[1])有5,4,3,2, 选择nums[3] =4 进行交换， 即[1,4,5,3,3,2]
# 3. 因下一个更大的排列, l位置后的子序列要尽可能的小, 也就是对下标l后的子序列进行升序排列
#    [1,4,5,3,3,2], 因下标l位置后的子序列符合降序, 现只需反转下标l后的元素，即得到[1,4,2,3,3,5]

# 以[1,3,5,4,3,2] debug
# 找到下标i为2, 进行交换, 交换后数组为[1,4,5,3,3,2]
# 对下标2后的子序列进行反转
# i为2, j为0, 进行交换, 元素5与元素2进行交换, 最终为[1,4,2,3,3,5]
# i为2, j为1, 进行交换, 元素3与元素3进行交换，最终为[1,4,2,3,3,5]
# 返回[1,4,2,3,3,5]
def aa(nums):
    for i in range(len(nums)-1, 0, -1):
        # 找到下标l位置(从后往前遍历, 找到不满足升序的第一个元素), l即i-1
        if nums[i-1] < nums[i]:
            for j in range(len(nums)-1, i-1, -1):
                # 找到下标l后, 由于l后元素是降序的, 从后往前遍历找到大于下标l位置的元素，然后进行两者交换
                if nums[j] > nums[i-1]:
                    nums[i-1], nums[j] = nums[j], nums[i-1]
                    break
            # 将下标l后的子序列进行反转
            for j in range((len(nums)-i+1) // 2):
                nums[i+j], nums[len(nums)-1-j] = nums[len(nums)-1-j], nums[i+j]
            return nums
    nums.reverse()
    return nums 


if __name__ == "__main__":
    print aa([1,2,3])
    print aa([3,2,1])
    print aa([1,1,5])
    print aa([1,3,5,4,3,2])
